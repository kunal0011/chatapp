generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String               @id @default(cuid())
  phone         String               @unique
  displayName   String
  passwordHash  String
  isActive      Boolean              @default(true)
  lastSeen      DateTime             @default(now())
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  messages      Message[]
  memberships   ConversationMember[]
  refreshTokens RefreshToken[]
  contacts      UserContact[]        @relation("UserToContacts")
  addedBy       UserContact[]        @relation("UserAsContact")
  pushTokens    PushToken[]
  blockedUsers  BlockedUser[]        @relation("BlockerToBlocked")
  blockedBy     BlockedUser[]        @relation("BlockedToBlocker")
  reactions     Reaction[]
  keyBundle     UserKeyBundle?
  senderKeysSent     SenderKeyDistribution[] @relation("SenderKeysSent")
  senderKeysReceived SenderKeyDistribution[] @relation("SenderKeysReceived")
}

model OtpVerification {
  phone     String   @id
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model BlockedUser {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())
  blocker   User     @relation("BlockerToBlocked", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("BlockedToBlocker", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
}

model PushToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model UserContact {
  id               String   @id @default(cuid())
  ownerId          String
  contactId        String
  createdAt        DateTime @default(now())
  knownIdentityKey String?  // last-seen identity key for this contact (base64); used for key change detection
  ikVerifiedAt     DateTime? // when the user last verified the safety number
  owner            User     @relation("UserToContacts", fields: [ownerId], references: [id], onDelete: Cascade)
  contact          User     @relation("UserAsContact", fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([ownerId, contactId])
  @@index([ownerId])
}

model Conversation {
  id          String               @id @default(cuid())
  type        ConversationType     @default(DIRECT)
  name        String?
  description String?
  avatarUrl   String?
  creatorId   String?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  members     ConversationMember[]
  messages    Message[]
  senderKeys  SenderKeyDistribution[]

  @@index([updatedAt])
}

model ConversationMember {
  id                     String       @id @default(cuid())
  conversationId         String
  userId                 String
  role                   MemberRole   @default(MEMBER)
  isMuted                Boolean      @default(false)
  lastReadMessageId      String?
  lastDeliveredMessageId String?
  joinedAt               DateTime     @default(now())
  conversation           Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user                   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  lastReadMessage        Message?     @relation("LastRead", fields: [lastReadMessageId], references: [id], onDelete: SetNull)
  lastDeliveredMessage   Message?     @relation("LastDelivered", fields: [lastDeliveredMessageId], references: [id], onDelete: SetNull)

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id                 String               @id @default(cuid())
  conversationId     String
  senderId           String
  parentId           String?
  content            String
  type               MessageType          @default(USER)
  status             MessageStatus        @default(SENT)
  isDeleted          Boolean              @default(false)
  isEdited           Boolean              @default(false)
  isEncrypted        Boolean              @default(false)
  ephemeralKey       String?               // base64 X3DH ephemeral public key (first message of session)
  senderPlaintext    String?               // AES-encrypted plaintext for sender's own history recovery
  createdAt          DateTime             @default(now())
  conversation       Conversation         @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender             User                 @relation(fields: [senderId], references: [id], onDelete: Restrict)
  parent             Message?             @relation("Replies", fields: [parentId], references: [id], onDelete: SetNull)
  replies            Message[]            @relation("Replies")
  reactions          Reaction[]
  readByMembers      ConversationMember[] @relation("LastRead")
  deliveredToMembers ConversationMember[] @relation("LastDelivered")

  @@index([conversationId, createdAt])
}

model UserKeyBundle {
  id             String   @id @default(cuid())
  userId         String   @unique
  identityKey    String // base64 Curve25519 public key
  signedPreKey   String // base64 JSON: {keyId, publicKey, signature}
  oneTimePreKeys String // base64 JSON array: [{keyId, publicKey}, ...]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum MemberRole {
  ADMIN
  MEMBER
}

enum MessageType {
  USER
  SYSTEM
}

model Reaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

model RefreshToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  familyId  String?
  isUsed    Boolean   @default(false)
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([familyId])
  @@index([expiresAt])
}

model SenderKeyDistribution {
  id               String       @id @default(cuid())
  groupId          String
  senderUserId     String
  recipientUserId  String
  encryptedKey     String       // 1:1 E2EE encrypted SenderKeyDistribution JSON blob
  createdAt        DateTime     @default(now())
  group            Conversation @relation(fields: [groupId], references: [id], onDelete: Cascade)
  sender           User         @relation("SenderKeysSent", fields: [senderUserId], references: [id], onDelete: Cascade)
  recipient        User         @relation("SenderKeysReceived", fields: [recipientUserId], references: [id], onDelete: Cascade)

  @@unique([groupId, senderUserId, recipientUserId])
  @@index([recipientUserId, groupId])
}

enum ConversationType {
  DIRECT
  GROUP
}
